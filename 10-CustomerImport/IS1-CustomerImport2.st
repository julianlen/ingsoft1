Object subclass: #Address	instanceVariableNames: 'id streetName streetNumber town zipCode province'	classVariableNames: ''	poolDictionaries: ''	category: 'IS1-CustomerImport-Model'!!Address methodsFor: 'zip code' stamp: 'HernanWilkinson 10/28/2016 16:13'!zipCode	^zipCode! !!Address methodsFor: 'zip code' stamp: 'HernanWilkinson 10/28/2016 16:08'!zipCode: aZipCode 	zipCode := aZipCode! !!Address methodsFor: 'as yet unclassified' stamp: 'HernanWilkinson 11/1/2016 10:06'!isAt: aStreetName	^streetName = aStreetName ! !!Address methodsFor: 'province' stamp: 'HernanWilkinson 10/28/2016 16:11'!province	^province! !!Address methodsFor: 'province' stamp: 'HernanWilkinson 10/28/2016 16:08'!province: aProvince 	province := aProvince	! !!Address methodsFor: 'street' stamp: 'HernanWilkinson 10/28/2016 16:12'!streetName	^streetName ! !!Address methodsFor: 'street' stamp: 'HernanWilkinson 10/28/2016 13:27'!streetName: aStreetName 	streetName := aStreetName ! !!Address methodsFor: 'street' stamp: 'HernanWilkinson 10/28/2016 13:27'!streetNumber: aStreetNumber 	streetNumber := aStreetNumber ! !!Address methodsFor: 'street' stamp: 'HernanWilkinson 10/28/2016 16:12'!streetNumber	^streetNumber ! !!Address methodsFor: 'twon' stamp: 'HernanWilkinson 10/28/2016 16:07'!town: aTown 	town := aTown! !!Address methodsFor: 'twon' stamp: 'HernanWilkinson 10/28/2016 16:12'!town	^town! !Object subclass: #Customer	instanceVariableNames: 'id firstName lastName identificationType identificationNumber addresses'	classVariableNames: ''	poolDictionaries: ''	category: 'IS1-CustomerImport-Model'!!Customer methodsFor: 'name' stamp: 'HernanWilkinson 10/28/2016 16:15'!firstName		^firstName ! !!Customer methodsFor: 'name' stamp: 'HernanWilkinson 10/28/2016 13:09'!lastName: aLastName 	lastName := aLastName! !!Customer methodsFor: 'name' stamp: 'HernanWilkinson 10/28/2016 16:15'!lastName	^lastName ! !!Customer methodsFor: 'name' stamp: 'HernanWilkinson 10/28/2016 13:09'!firstName: aName 	firstName := aName! !!Customer methodsFor: 'addresses' stamp: 'HernanWilkinson 11/1/2016 09:43'!numberOfAddresses		^addresses size! !!Customer methodsFor: 'addresses' stamp: 'HernanWilkinson 10/28/2016 13:25'!addresses	^ addresses! !!Customer methodsFor: 'addresses' stamp: 'JulianLen 6/22/2018 21:03'!hasEmptyAddresses	^self addresses isEmpty! !!Customer methodsFor: 'addresses' stamp: 'HernanWilkinson 10/28/2016 13:27'!addAddress: anAddress 	addresses add: anAddress ! !!Customer methodsFor: 'as yet unclassified' stamp: 'HernanWilkinson 11/1/2016 10:05'!addressAt: aStreetName ifNone: noneClosure 		^addresses detect: [ :anAddress | anAddress isAt: aStreetName ] ifNone: noneClosure ! !!Customer methodsFor: 'initialization' stamp: 'HernanWilkinson 10/28/2016 13:26'!initialize	super initialize.	addresses := OrderedCollection new.! !!Customer methodsFor: 'identification' stamp: 'HernanWilkinson 10/28/2016 16:13'!identificationType		^identificationType ! !!Customer methodsFor: 'identification' stamp: 'HernanWilkinson 10/28/2016 13:10'!identificationNumber: anIdentificationNumber 	identificationNumber := anIdentificationNumber! !!Customer methodsFor: 'identification' stamp: 'HernanWilkinson 10/28/2016 13:10'!identificationType: anIdentificationType 	identificationType := anIdentificationType! !!Customer methodsFor: 'identification' stamp: 'HernanWilkinson 10/28/2016 16:13'!identificationNumber		^identificationNumber ! !TestCase subclass: #CustomerImportTest	instanceVariableNames: 'session importer testObjectFactory'	classVariableNames: ''	poolDictionaries: ''	category: 'IS1-CustomerImport-Model'!!CustomerImportTest methodsFor: 'testing' stamp: 'JulianLen 6/23/2018 14:25'!test02CanNotImportLessThan5FieldsInCustomer		self 		should: [self importCustomersFrom: testObjectFactory invalidTestDataWithLessFieldsInCustomer on: session.  ]		raise: Error		withExceptionDo: [ :anError |			self assert: anError messageText = CustomerImporter invalidQuantityOfFieldsErrorMessage.				self assertHaveNotImportedCustomers. ]	! !!CustomerImportTest methodsFor: 'testing' stamp: 'JulianLen 6/23/2018 14:27'!test05FirstRecordDataCanNotBeAnAddress		self 		should: [self importCustomersFrom: testObjectFactory invalidDataWithAddressFirstInData on: session.  ]		raise: Error		withExceptionDo: [ :anError |			self assert: anError messageText = CustomerImporter invalidAddressWithoutCustomerErrorMessage.				self assertHaveNotImportedCustomers. ]	! !!CustomerImportTest methodsFor: 'testing' stamp: 'JulianLen 6/23/2018 14:25'!test08CanNotImportMoreThan6FieldsInAddress		self 		should: [self importCustomersFrom: testObjectFactory invalidTestDataWithMoreFieldsInAddress on: session.  ]		raise: Error		withExceptionDo: [ :anError |			self assert: anError messageText = CustomerImporter invalidQuantityOfFieldsErrorMessage .				self assertPepeSanchezWasImportedCorrectlyWithoutAddress 								 ]	! !!CustomerImportTest methodsFor: 'testing' stamp: 'JulianLen 6/23/2018 14:25'!test03CanNotImportMoreThan5FieldsInCustomer		self 		should: [self importCustomersFrom: testObjectFactory invalidTestDataWithLongerFieldsInCustomer on: session.  ]		raise: Error		withExceptionDo: [ :anError |			self assert: anError messageText = CustomerImporter invalidQuantityOfFieldsErrorMessage.				self assertHaveNotImportedCustomers. ]	! !!CustomerImportTest methodsFor: 'testing' stamp: 'JulianLen 6/23/2018 14:25'!test06CanNotImportAddressWithTypeOfRecordDifferentOfA		self 		should: [self importCustomersFrom: testObjectFactory invalidTestDataWithInvalidTypeOfRecordInAddress on: session.  ]		raise: Error		withExceptionDo: [ :anError |			self assert: anError messageText = CustomerImporter invalidTypeOfRecordErrorMessage.				self assertPepeSanchezWasImportedCorrectlyWithoutAddress 								 ]	! !!CustomerImportTest methodsFor: 'testing' stamp: 'JulianLen 6/25/2018 14:09'!test10CanNotImportZipCodeWithoutNumber		self 		should: [self importCustomersFrom: testObjectFactory invalidTestDataWithInvalidZipCode on: session.  ]		raise: Error		withExceptionDo: [ :anError |			self assert: anError messageText = CustomerImporter invalidZipCodeErrorMessage .				self assertPepeSanchezWasImportedCorrectlyWithoutAddress 								 ]	! !!CustomerImportTest methodsFor: 'testing' stamp: 'JulianLen 6/23/2018 14:26'!test01ImportCustomersWorkCorrectly	self importCustomersFrom: testObjectFactory validTestData on: session.	self assertImportedCustomersSizeIsCorrect.	self assertPepeSanchezWasImportedCorrectly.	self assertJuanPerezWasImportedCorrectly! !!CustomerImportTest methodsFor: 'testing' stamp: 'JulianLen 6/25/2018 14:08'!test09CanNotImportStreetNumberWithoutNumber		self 		should: [self importCustomersFrom: testObjectFactory invalidTestDataWithInvalidStreetNumber on: session.  ]		raise: Error		withExceptionDo: [ :anError |			self assert: anError messageText = CustomerImporter invalidStreetNumberErrorMessage .				self assertPepeSanchezWasImportedCorrectlyWithoutAddress 								 ]	! !!CustomerImportTest methodsFor: 'testing' stamp: 'JulianLen 6/23/2018 14:25'!test04CanNotImportACustomerWithTypeOfRecordDifferentOfC		self 		should: [self importCustomersFrom: testObjectFactory invalidTypeOfRecordData on: session.  ]		raise: Error		withExceptionDo: [ :anError |			self assert: anError messageText = CustomerImporter invalidTypeOfRecordErrorMessage.				self assertHaveNotImportedCustomers. ]	! !!CustomerImportTest methodsFor: 'testing' stamp: 'JulianLen 6/23/2018 14:25'!test07CanNotImportLessThan6FieldsInAddress		self 		should: [self importCustomersFrom: testObjectFactory invalidTestDataWithLessFieldsInAddress on: session.  ]		raise: Error		withExceptionDo: [ :anError |			self assert: anError messageText = CustomerImporter invalidQuantityOfFieldsErrorMessage .				self assertPepeSanchezWasImportedCorrectlyWithoutAddress 								 ]	! !!CustomerImportTest methodsFor: 'setup-teardown' stamp: 'HernanWilkinson 11/1/2016 15:23'!addressMapping	^ ClassMapping		withDefaultTableNameFor: Address		mappingAll:			(Array				with: (EmbededMapping withDefaultFieldNameFor: #streetName)				with: (EmbededMapping withDefaultFieldNameFor: #streetNumber)				with: (EmbededMapping withDefaultFieldNameFor: #town)				with: (EmbededMapping withDefaultFieldNameFor: #zipCode)				with: (EmbededMapping withDefaultFieldNameFor: #province))! !!CustomerImportTest methodsFor: 'setup-teardown' stamp: 'HernanWilkinson 11/1/2016 15:24'!customerMapping	^ ClassMapping		withDefaultTableNameFor: Customer		mappingAll:			(Array				with: (EmbededMapping withDefaultFieldNameFor: #firstName)				with: (EmbededMapping withDefaultFieldNameFor: #lastName)				with: (EmbededMapping withDefaultFieldNameFor: #identificationType)				with: (EmbededMapping withDefaultFieldNameFor: #identificationNumber)				with: (OneToManyMapping withDefaultFieldNameFor: #addresses ofType: Address))! !!CustomerImportTest methodsFor: 'setup-teardown' stamp: 'JulianLen 6/23/2018 14:23'!setUp	testObjectFactory := TestObjectFactory new.	session := DataBaseSession for: (Array with: self addressMapping with: self customerMapping).	session open.	session beginTransaction! !!CustomerImportTest methodsFor: 'setup-teardown' stamp: 'HernanWilkinson 11/1/2016 15:23'!tearDown	session commit.	session close! !!CustomerImportTest methodsFor: 'importing' stamp: 'HernanWilkinson 11/1/2016 15:17'!customerIdentifiedAs: anIdentifycationType numbered: anIdentificationNumber		|customers |		customers := session 		select: [ :aCustomer | aCustomer identificationType = anIdentifycationType and: [ aCustomer identificationNumber = anIdentificationNumber ] ]		ofType: Customer.			self assert: customers size equals: 1.		^customers anyOne.! !!CustomerImportTest methodsFor: 'importing' stamp: 'JulianLen 6/21/2018 20:17'!importCustomersFrom: inputStream on: aSession	(CustomerImporter importCustomersFrom: inputStream on: aSession) value! !!CustomerImportTest methodsFor: 'asserting' stamp: 'HernanWilkinson 11/1/2016 10:56'!assert: customer isNamed: firstName lastName: lastName identfiedAs: idType withNumber: idNumber andNumberOfAddresses: addressesSize	self assert: customer firstName equals: firstName.	self assert: customer lastName equals: lastName.	self assert: customer identificationType equals: idType.	self assert: customer identificationNumber equals: idNumber.	self assert: customer numberOfAddresses equals: addressesSize .! !!CustomerImportTest methodsFor: 'asserting' stamp: 'HernanWilkinson 11/1/2016 15:14'!assertJuanPerezWasImportedCorrectly		| customer idType idNumber |		idType := 'C'.	idNumber := '23-25666777-9'.	customer := self customerIdentifiedAs: idType numbered: idNumber.		self assert: customer isNamed: 'Juan' lastName: 'Perez' identfiedAs: idType withNumber: idNumber andNumberOfAddresses: 1.	self assert: customer hasAddressAt: 'Alem' number: 1122 in: 'CABA' zipCode: 1001 province: 'CABA'.	! !!CustomerImportTest methodsFor: 'asserting' stamp: 'HernanWilkinson 11/1/2016 11:00'!assert: customer hasAddressAt: streetName number: streetNumber in: town zipCode: zipCode province: province	| address |		address := customer addressAt: streetName ifNone: [ self fail ].	self assert: address streetName equals: streetName.	self assert: address streetNumber equals: streetNumber.	self assert: address town equals: town.	self assert: address zipCode equals: zipCode.	self assert: address province equals: province.	! !!CustomerImportTest methodsFor: 'asserting' stamp: 'JulianLen 6/22/2018 21:06'!assertPepeSanchezWasImportedCorrectlyWithoutAddress	| customer idType idNumber |	idType := 'D'.	idNumber := '22333444'.	customer := self customerIdentifiedAs: idType numbered: idNumber.		self assert: customer isNamed: 'Pepe' lastName: 'Sanchez' identfiedAs: idType withNumber: idNumber andNumberOfAddresses: 0.	self assert: customer hasEmptyAddresses ! !!CustomerImportTest methodsFor: 'asserting' stamp: 'HernanWilkinson 11/1/2016 15:13'!assertImportedCustomersSizeIsCorrect		self assert: (session selectAllOfType: Customer) size equals: 2.	! !!CustomerImportTest methodsFor: 'asserting' stamp: 'HernanWilkinson 11/1/2016 15:16'!assertPepeSanchezWasImportedCorrectly	| customer idType idNumber |	idType := 'D'.	idNumber := '22333444'.	customer := self customerIdentifiedAs: idType numbered: idNumber.		self assert: customer isNamed: 'Pepe' lastName: 'Sanchez' identfiedAs: idType withNumber: idNumber andNumberOfAddresses: 2.	self assert: customer hasAddressAt: 'San Martin' number: 3322 in: 'Olivos' zipCode: 1636 province: 'BsAs'.	self assert: customer hasAddressAt: 'Maipu' number: 888 in: 'Florida' zipCode: 1122 province: 'Buenos Aires'! !!CustomerImportTest methodsFor: 'asserting' stamp: 'JulianLen 6/21/2018 23:56'!assertHaveNotImportedCustomers		self assert: (session selectAllOfType: Customer) size equals: 0.	! !Object subclass: #CustomerImporter	instanceVariableNames: 'inputStream session newCustomer line temporalRecord newAddress'	classVariableNames: ''	poolDictionaries: ''	category: 'IS1-CustomerImport-Model'!!CustomerImporter methodsFor: 'importing' stamp: 'JulianLen 6/23/2018 15:10'!createTemporalRecord	temporalRecord := self splitLine! !!CustomerImporter methodsFor: 'importing' stamp: 'JulianLen 6/23/2018 15:18'!assertAddressRecordHasCorrectLength	(temporalRecord size < 6 or: [ temporalRecord size > 6 ])		ifTrue: [ self error: self class invalidQuantityOfFieldsErrorMessage ]! !!CustomerImporter methodsFor: 'importing' stamp: 'JulianLen 6/23/2018 15:03'!assertIsACorrectRecordDataType	(temporalRecord first ~= 'C' and: [ temporalRecord first ~= 'A' ])		ifTrue: [ self error: self class invalidTypeOfRecordErrorMessage ]! !!CustomerImporter methodsFor: 'importing' stamp: 'JulianLen 6/23/2018 15:07'!importCustomerRecordAndPersist	newCustomer := Customer new.	newCustomer firstName: temporalRecord second.	newCustomer lastName: temporalRecord third.	newCustomer identificationType: temporalRecord fourth.	newCustomer identificationNumber:	temporalRecord fifth.	session persist: newCustomer! !!CustomerImporter methodsFor: 'importing' stamp: 'JulianLen 6/25/2018 15:22'!assertAddresHasCorrectStreetNumber	temporalRecord third isAllDigits		ifFalse: [ self error: self class invalidStreetNumberErrorMessage ]! !!CustomerImporter methodsFor: 'importing' stamp: 'JulianLen 6/21/2018 20:07'!importCustomersFrom: anInputStream on: aSession	inputStream := anInputStream .	session := aSession ! !!CustomerImporter methodsFor: 'importing' stamp: 'JulianLen 6/25/2018 15:22'!assertAddresHasCorrectZipCode	temporalRecord fifth isAllDigits		ifFalse: [ self error: self class invalidZipCodeErrorMessage ]! !!CustomerImporter methodsFor: 'importing' stamp: 'JulianLen 6/23/2018 15:18'!assertCustomerRecordHasCorrectLength	(temporalRecord size > 5 or: [ temporalRecord size < 5 ])		ifTrue: [ self error: self class invalidQuantityOfFieldsErrorMessage ]! !!CustomerImporter methodsFor: 'importing' stamp: 'JulianLen 6/23/2018 15:20'!value	[ line := inputStream nextLine.	line notNil ]		whileTrue: [ 			self createTemporalRecord.			self assertIsACorrectRecordDataType.			self importTemporalRecord 			]! !!CustomerImporter methodsFor: 'importing' stamp: 'JulianLen 6/25/2018 15:21'!importAddressRecord	newAddress := Address new.	newAddress streetName: temporalRecord second.	newAddress streetNumber: temporalRecord third asInteger.	newAddress town: temporalRecord fourth.	newAddress zipCode: temporalRecord fifth asInteger.	newAddress province: temporalRecord sixth.	newCustomer addAddress: newAddress! !!CustomerImporter methodsFor: 'importing' stamp: 'JulianLen 6/25/2018 15:22'!importTemporalRecord	self isTemporalRecordCustomer		ifTrue: [ self assertCustomerRecordHasCorrectLength.			self importCustomerRecordAndPersist ].	self isTemporalRecordAddress		ifTrue: [ self assertHasCustomer.			self assertAddressRecordHasCorrectLength.			self assertAddresHasCorrectStreetNumber.			self assertAddresHasCorrectZipCode.			self importAddressRecord ]! !!CustomerImporter methodsFor: 'importing' stamp: 'JulianLen 6/23/2018 15:04'!isTemporalRecordAddress	^ temporalRecord first = 'A'! !!CustomerImporter methodsFor: 'importing' stamp: 'JulianLen 6/23/2018 15:04'!isTemporalRecordCustomer	^ temporalRecord first = 'C'! !!CustomerImporter methodsFor: 'importing' stamp: 'JulianLen 6/23/2018 15:01'!splitLine	^ line substrings: {$,}! !!CustomerImporter methodsFor: 'importing' stamp: 'JulianLen 6/23/2018 15:17'!assertHasCustomer	newCustomer isNil		ifTrue: [ self error: self class invalidAddressWithoutCustomerErrorMessage ]! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!CustomerImporter class	instanceVariableNames: ''!!CustomerImporter class methodsFor: 'importing' stamp: 'JulianLen 6/21/2018 23:53'!invalidQuantityOfFieldsErrorMessage	^'Invalid quantity of fields'! !!CustomerImporter class methodsFor: 'importing' stamp: 'JulianLen 6/22/2018 20:35'!invalidAddressWithoutCustomerErrorMessage	^'The address has not a customer'! !!CustomerImporter class methodsFor: 'importing' stamp: 'JulianLen 6/22/2018 00:10'!invalidTypeOfRecordErrorMessage	^'Invalid type of record'! !!CustomerImporter class methodsFor: 'importing' stamp: 'JulianLen 6/25/2018 14:09'!invalidStreetNumberErrorMessage	^'Invalid street number'! !!CustomerImporter class methodsFor: 'importing' stamp: 'JulianLen 6/21/2018 20:06'!importCustomersFrom: anInputStream on: aSession ^ self new importCustomersFrom: anInputStream on: aSession! !!CustomerImporter class methodsFor: 'importing' stamp: 'JulianLen 6/25/2018 14:10'!invalidZipCodeErrorMessage	^'Invalid Zip Code'! !Object subclass: #TestObjectFactory	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'IS1-CustomerImport-Model'!!TestObjectFactory methodsFor: 'test data' stamp: 'JulianLen 6/23/2018 14:25'!invalidTestDataWithLongerFieldsInCustomer	^ ReadStream on:'C,Pepe,Sanchez,D,22333444,invalidField'! !!TestObjectFactory methodsFor: 'test data' stamp: 'JulianLen 6/25/2018 13:53'!invalidTestDataWithMoreFieldsInAddress	^ ReadStream on:'C,Pepe,Sanchez,D,22333444A,San Martin,3322,Olivos,1636, CABA,A'! !!TestObjectFactory methodsFor: 'test data' stamp: 'JulianLen 6/23/2018 14:25'!invalidTestDataWithLessFieldsInCustomer	^ ReadStream on:'C,Pepe,Sanchez,D'! !!TestObjectFactory methodsFor: 'test data' stamp: 'JulianLen 6/23/2018 14:25'!invalidTestDataWithLessFieldsInAddress	^ ReadStream on:'C,Pepe,Sanchez,D,22333444A,San Martin,3322,Olivos,1636'! !!TestObjectFactory methodsFor: 'test data' stamp: 'JulianLen 6/23/2018 14:27'!invalidDataWithAddressFirstInData	^ ReadStream on:'A,Pepe,Sanchez,D,22333444'! !!TestObjectFactory methodsFor: 'test data' stamp: 'JulianLen 6/25/2018 14:10'!invalidTestDataWithInvalidZipCode	^ ReadStream on: 	'C,Pepe,Sanchez,D,22333444A,San Martin,3322,Olivos,A,BsAs'! !!TestObjectFactory methodsFor: 'test data' stamp: 'JulianLen 6/23/2018 14:25'!invalidTestDataWithInvalidTypeOfRecordInAddress	^ ReadStream on:'C,Pepe,Sanchez,D,22333444AB,San Martin,3322,Olivos,1636,BsAs'! !!TestObjectFactory methodsFor: 'test data' stamp: 'JulianLen 6/25/2018 14:06'!validTestData	^ ReadStream on: 	'C,Pepe,Sanchez,D,22333444A,San Martin,3322,Olivos,1636,BsAsA,Maipu,888,Florida,1122,Buenos AiresC,Juan,Perez,C,23-25666777-9A,Alem,1122,CABA,1001,CABA'! !!TestObjectFactory methodsFor: 'test data' stamp: 'JulianLen 6/25/2018 14:09'!invalidTestDataWithInvalidStreetNumber	^ ReadStream on: 	'C,Pepe,Sanchez,D,22333444A,San Martin,A,Olivos,1636,BsAs'! !!TestObjectFactory methodsFor: 'test data' stamp: 'JulianLen 6/23/2018 14:33'!invalidTypeOfRecordData	^ ReadStream on:'CD,Pepe,Sanchez,D,22333444'! !Object subclass: #ClassMapping	instanceVariableNames: 'mappedClass mappings tableName'	classVariableNames: ''	poolDictionaries: ''	category: 'IS1-CustomerImport-PersistanceModel'!!ClassMapping methodsFor: 'mapping' stamp: 'HernanWilkinson 11/1/2016 00:40'!map: anObject using: aDataBaseSession	| record |	self toDo: 'se puede optimizar usando array para registros y guardando definicion de tabla una vez'.	record := Dictionary new.		self mapIdOf: anObject into: record using: aDataBaseSession.	self mapEmbededOf: anObject into: record.	"agrego aca el registro y no luego de mapear el id para que lo agrege completo. Lo agrego antes de mapear las rel one to many 	porque si usuara una db de verdad habria foreign key constrain"	aDataBaseSession add: record on: self tableName.	self mapOneToManyRelationshipsOf: anObject using: aDataBaseSession! !!ClassMapping methodsFor: 'mapping' stamp: 'HernanWilkinson 11/1/2016 00:42'!unmap: aRecord using: aDataBaseSession	| unMappedObject |	unMappedObject := mappedClass basicNew.	self unmapIdOf: aRecord into: unMappedObject.	self unmap: aRecord into: unMappedObject using: aDataBaseSession.	^ unMappedObject! !!ClassMapping methodsFor: 'mapping - private' stamp: 'HernanWilkinson 11/1/2016 00:40'!mapOneToManyRelationshipsOf: anObject using: aDataBaseSession	mappings do: [ :aMapping | aMapping mapOneToManyRelationshipsOf: anObject using: aDataBaseSession ]! !!ClassMapping methodsFor: 'mapping - private' stamp: 'HernanWilkinson 11/1/2016 00:40'!mapIdOf: anObject into: record using: aDataBaseSession	| newId |	newId := aDataBaseSession newIdFor: anObject.	anObject instVarNamed: #id put: newId.	record at: #id put: newId! !!ClassMapping methodsFor: 'mapping - private' stamp: 'HernanWilkinson 11/1/2016 00:43'!unmap: aRecord into: unMappedObject using: aDataBaseSession	mappings do: [ :aMapping | aMapping unmap: aRecord into: unMappedObject using: aDataBaseSession ]! !!ClassMapping methodsFor: 'mapping - private' stamp: 'HernanWilkinson 11/1/2016 00:40'!mapEmbededOf: anObject into: record	mappings do: [ :aMapping | aMapping embeded: anObject into: record ]! !!ClassMapping methodsFor: 'mapping - private' stamp: 'HernanWilkinson 11/1/2016 00:43'!unmapIdOf: aRecord into: unMappedObject	unMappedObject instVarNamed: #id put: (aRecord at: #id)! !!ClassMapping methodsFor: 'testing' stamp: 'HernanWilkinson 10/31/2016 23:02'!isFor: aClass	^mappedClass = aClass! !!ClassMapping methodsFor: 'initialization' stamp: 'HernanWilkinson 10/31/2016 23:25'!initializeFor: aClass into: aTableName mappingAll: aCollectionOfMappings	mappedClass := aClass.	tableName := aTableName.	mappings := aCollectionOfMappings ! !!ClassMapping methodsFor: 'table' stamp: 'HernanWilkinson 10/31/2016 23:25'!tableName		^tableName ! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!ClassMapping class	instanceVariableNames: ''!!ClassMapping class methodsFor: 'assertions' stamp: 'HernanWilkinson 10/31/2016 21:15'!assertHasIdInstanceVariable: aClass 		(aClass hasInstVarNamed: #id) ifFalse: [ self error: ('<1s> has no id instance variable' expandMacrosWith: aClass name) ]! !!ClassMapping class methodsFor: 'assertions' stamp: 'HernanWilkinson 10/31/2016 19:26'!assertValidMappings: aCollectionOfMappings for: aClass 	self toDo: 'Lo mejor seria recolectar todos los erroes de mapeo y no parar en el primero'.	aCollectionOfMappings do: [ :aMapping | aMapping assertIsValidFor: aClass ]	! !!ClassMapping class methodsFor: 'assertions' stamp: 'HernanWilkinson 10/31/2016 23:41'!assertValidTableName: aTableName	aTableName trimBoth isEmpty ifTrue: [ self error: 'Table name can not be empty' ]! !!ClassMapping class methodsFor: 'instance creation' stamp: 'HernanWilkinson 11/1/2016 00:44'!defaultTableNameFor: aClass		^aClass name asString! !!ClassMapping class methodsFor: 'instance creation' stamp: 'HernanWilkinson 10/31/2016 23:24'!for: aClass into: aTableName mappingAll: aCollectionOfMappings	self assertValidTableName: aTableName.	self assertHasIdInstanceVariable: aClass.	self assertValidMappings: aCollectionOfMappings for: aClass.		^self new initializeFor: aClass into: aTableName mappingAll: aCollectionOfMappings		! !!ClassMapping class methodsFor: 'instance creation' stamp: 'HernanWilkinson 10/31/2016 23:23'!withDefaultTableNameFor: aClass mappingAll: aCollectionOfMappings	^self for: aClass into: (self defaultTableNameFor: aClass) mappingAll: aCollectionOfMappings		! !Object subclass: #DataBaseSession	instanceVariableNames: 'configuration tables id cache'	classVariableNames: ''	poolDictionaries: ''	category: 'IS1-CustomerImport-PersistanceModel'!!DataBaseSession methodsFor: 'tables - private' stamp: 'HernanWilkinson 11/1/2016 00:48'!tableNamed: aTableName	^ tables at: aTableName ifAbsentPut: [ Dictionary new ]! !!DataBaseSession methodsFor: 'tables - private' stamp: 'HernanWilkinson 11/1/2016 01:12'!relationTableNameOwnedBy: anOwnerClass relatedTo: aRelatedClass	| ownerClassMapper relatedClassMapper |		ownerClassMapper := self mapperFor: anOwnerClass.	relatedClassMapper := self mapperFor: aRelatedClass.		^ownerClassMapper tableName,'_', relatedClassMapper tableName asPlural.! !!DataBaseSession methodsFor: 'tables - private' stamp: 'HernanWilkinson 11/1/2016 01:12'!relationTableFor: anOwnerClass relatedTo: aRelatedClass	| relationTableName table |	relationTableName := self relationTableNameOwnedBy: anOwnerClass relatedTo: aRelatedClass.	table := self tableNamed: relationTableName.		^ table! !!DataBaseSession methodsFor: 'transaction management' stamp: 'HernanWilkinson 10/31/2016 22:55'!assertInTransaction		cache isNil ifTrue: [ self error: 'There is no transaction currently' ]! !!DataBaseSession methodsFor: 'transaction management' stamp: 'HernanWilkinson 10/31/2016 22:57'!beginTransaction	self assertIsOpen.	self assertNotInTransasction.		cache := WeakKeyDictionary new.	! !!DataBaseSession methodsFor: 'transaction management' stamp: 'HernanWilkinson 10/31/2016 22:55'!assertNotInTransasction		cache notNil ifTrue: [ self error: 'There is an open transaction already' ]! !!DataBaseSession methodsFor: 'transaction management' stamp: 'HernanWilkinson 10/31/2016 22:57'!commit		self assertInTransaction.		cache := nil! !!DataBaseSession methodsFor: 'mapping - private' stamp: 'HernanWilkinson 11/1/2016 01:15'!relatedOfType: aRelatedClass for: anOwner	| table relatedIds |		table := self relationTableFor: anOwner class relatedTo: aRelatedClass.	relatedIds := table at: (self idOf: anOwner) ifAbsent: [ ^#() ].		^relatedIds collect: [ :aRelatedId | self objectIdentifiedAs: aRelatedId ofType: aRelatedClass ]		! !!DataBaseSession methodsFor: 'mapping - private' stamp: 'HernanWilkinson 11/1/2016 01:14'!mapperFor: aClass	self toDo: 'se puede mejorar performanco usando un dictionary'.	^configuration		detect: [ :aClassMapper | aClassMapper isFor: aClass ] 		ifNone: [ self error: ('There is no mapper for <1s>' expandMacrosWith: aClass name) ]! !!DataBaseSession methodsFor: 'mapping - private' stamp: 'HernanWilkinson 11/1/2016 01:16'!unmapRecordIdentifiedAs: anId ofType: aClass	| record table mapper |	mapper := self mapperFor: aClass.	table := self tableNamed: mapper tableName.	record := table at: id ifAbsent: [ self error: ('Object identified as <1s> does not exist' expandMacrosWith: anId printString) ].		^ mapper unmap: record using: self! !!DataBaseSession methodsFor: 'selecting - private' stamp: 'HernanWilkinson 11/1/2016 01:28'!addInto: selected theOnesThatHold: aCondition unmapping: record with: mapper	| recordId aClassInstance |	recordId := self recordId: record.	aClassInstance := cache at: recordId ifAbsent: [ mapper unmap: record using: self ].	(aCondition value: aClassInstance) ifTrue: [ 		self addToCache: aClassInstance.		selected add: aClassInstance ].		^ selected! !!DataBaseSession methodsFor: 'persistance' stamp: 'HernanWilkinson 11/1/2016 01:28'!persist: anObject	| mapper |		self assertInTransaction.	self delay.		mapper := self mapperFor: anObject class.	mapper map: anObject using: self.		self addToCache: anObject ! !!DataBaseSession methodsFor: 'persistence - private' stamp: 'HernanWilkinson 10/28/2016 16:35'!defineIdOf: anObject	anObject instVarNamed: 'id' put: (self newIdFor: anObject).! !!DataBaseSession methodsFor: 'persistence - private' stamp: 'HernanWilkinson 10/28/2016 16:41'!delay	(Delay forMilliseconds: 100) wait! !!DataBaseSession methodsFor: 'adding - private' stamp: 'HernanWilkinson 11/1/2016 01:05'!assertRelationOwnedBy: anOwner isUniqueFor: aRelated identifiedAs: relatedId in: relatedIds	(relatedIds includes: relatedId) ifTrue: [ self signalRelationAlreadyExistBetween: anOwner and: aRelated ]! !!DataBaseSession methodsFor: 'adding - private' stamp: 'HernanWilkinson 11/1/2016 01:03'!add: aRecord on: aTableName	| table existingRecord |	table := self tableNamed: aTableName.	existingRecord := table at: (self recordId: aRecord) ifAbsentPut: [ aRecord ].	existingRecord == aRecord ifFalse: [ self error: 'Duplicated primary key' ]! !!DataBaseSession methodsFor: 'adding - private' stamp: 'HernanWilkinson 11/1/2016 01:00'!signalRelationAlreadyExistBetween: anOwner and: aRelated 	self error: ('Relation between id <1s> of type <2s> and id <3s> of type <4s> already exist'		expandMacrosWith: (self idOf: anOwner) printString		with: anOwner class name		with: (self idOf: aRelated) printString		with: aRelated class name)! !!DataBaseSession methodsFor: 'adding - private' stamp: 'HernanWilkinson 11/1/2016 01:10'!relatedIdsOwnedBy: anOwner forType: aRelatedClass	| relatedIds table |	table := self relationTableFor: anOwner class relatedTo: aRelatedClass.	relatedIds := self relatedIdOwnedBy: anOwner on: table.		^ relatedIds! !!DataBaseSession methodsFor: 'adding - private' stamp: 'HernanWilkinson 11/1/2016 01:03'!addRelated: aRelated ownedBy: anOwner	| relatedIds relatedId |	relatedIds := self relatedIdsOwnedBy: anOwner forType: aRelated class.	relatedId := aRelated instVarNamed: #id.	self assertRelationOwnedBy: anOwner isUniqueFor: aRelated identifiedAs: relatedId in: relatedIds.		relatedIds add: relatedId! !!DataBaseSession methodsFor: 'adding - private' stamp: 'HernanWilkinson 11/1/2016 01:27'!addToCache: anObject 	cache at: (self idOf: anObject) put: anObject ! !!DataBaseSession methodsFor: 'adding - private' stamp: 'HernanWilkinson 11/1/2016 01:06'!relatedIdOwnedBy: anOwner on: table	^ table at: (self idOf: anOwner) ifAbsentPut: [ Set new ]! !!DataBaseSession methodsFor: 'selecting' stamp: 'HernanWilkinson 11/1/2016 01:15'!objectIdentifiedAs: anId ofType: aClass	self assertInTransaction.	self delay.		^ cache at: anId ifAbsentPut: [ self unmapRecordIdentifiedAs: anId ofType: aClass ]! !!DataBaseSession methodsFor: 'selecting' stamp: 'HernanWilkinson 11/1/2016 01:26'!select: aCondition ofType: aClass	| mapper table |	self assertInTransaction.	self delay.		mapper := self mapperFor: aClass.	table := tables at: mapper tableName ifAbsent: [ ^ #() ].		^ table inject: OrderedCollection new into: [ :selected :record | self addInto: selected theOnesThatHold: aCondition unmapping: record with: mapper ]! !!DataBaseSession methodsFor: 'selecting' stamp: 'HernanWilkinson 10/31/2016 22:17'!selectAllOfType: aClass 		^self select: [ :anObject | true ] ofType: aClass! !!DataBaseSession methodsFor: 'id' stamp: 'HernanWilkinson 11/1/2016 01:04'!recordId: aRecord	^aRecord at: #id! !!DataBaseSession methodsFor: 'id' stamp: 'HernanWilkinson 11/1/2016 01:00'!idOf: anObject	^anObject instVarNamed: #id! !!DataBaseSession methodsFor: 'id' stamp: 'HernanWilkinson 10/28/2016 16:35'!newIdFor: anObject	id := id + 1.	^id! !!DataBaseSession methodsFor: 'initialization' stamp: 'HernanWilkinson 10/31/2016 22:55'!initializeFor: aConfiguration	configuration := aConfiguration.	id := 0.	tables := nil.	cache := nil.! !!DataBaseSession methodsFor: 'open/close' stamp: 'HernanWilkinson 10/31/2016 18:36'!open	self assertIsClose.		tables := Dictionary new.	! !!DataBaseSession methodsFor: 'open/close' stamp: 'HernanWilkinson 10/31/2016 22:14'!close	self assertIsOpen.		tables := nil! !!DataBaseSession methodsFor: 'open/close' stamp: 'HernanWilkinson 10/31/2016 18:36'!assertIsOpen		tables isNil ifTrue: [ self error: 'Session must be open to colaborate with it' ]! !!DataBaseSession methodsFor: 'open/close' stamp: 'HernanWilkinson 10/31/2016 18:37'!assertIsClose		tables isNil ifFalse: [ self error: 'Session must be close' ]! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!DataBaseSession class	instanceVariableNames: ''!!DataBaseSession class methodsFor: 'instance creation' stamp: 'HernanWilkinson 10/28/2016 13:07'!for: aConfiguration	^self new initializeFor: aConfiguration! !Object subclass: #Mapping	instanceVariableNames: 'instanceVariableName'	classVariableNames: ''	poolDictionaries: ''	category: 'IS1-CustomerImport-PersistanceModel'!!Mapping methodsFor: 'mapping' stamp: 'HernanWilkinson 10/31/2016 23:26'!mapOneToManyRelationshipsOf: anObject using: aDataBaseSession	self subclassResponsibility! !!Mapping methodsFor: 'mapping' stamp: 'HernanWilkinson 10/31/2016 23:26'!unmap: aRecord into: anObject using: aDataBaseSession	self subclassResponsibility! !!Mapping methodsFor: 'mapping' stamp: 'HernanWilkinson 10/31/2016 23:26'!embeded: anObject into: aRecord	self subclassResponsibility! !!Mapping methodsFor: 'assertions' stamp: 'HernanWilkinson 11/1/2016 01:31'!assertIsValidFor: aClass 	(aClass hasInstVarNamed: instanceVariableName) ifFalse: [ 		self error: ('Invalid mapping for <1s> in class <2s>' expandMacrosWith: instanceVariableName with: aClass name) ] ! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Mapping class	instanceVariableNames: ''!!Mapping class methodsFor: 'instance creation' stamp: 'HernanWilkinson 11/1/2016 01:32'!defaultFieldNameFor: anInstanceVariableName	^anInstanceVariableName asString! !!Mapping class methodsFor: 'assertions' stamp: 'HernanWilkinson 10/31/2016 23:41'!assertValidFieldName: aFieldName	aFieldName trimBoth isEmpty ifTrue: [ self error: 'Field name can not be empty' ]! !Mapping subclass: #EmbededMapping	instanceVariableNames: 'fieldName'	classVariableNames: ''	poolDictionaries: ''	category: 'IS1-CustomerImport-PersistanceModel'!!EmbededMapping methodsFor: 'mapping' stamp: 'HernanWilkinson 10/31/2016 21:23'!mapOneToManyRelationshipsOf: anObject using: aDataBaseSession 		! !!EmbededMapping methodsFor: 'mapping' stamp: 'HernanWilkinson 10/31/2016 23:31'!unmap: aRecord into: anObject using: aDataBaseSession 	anObject instVarNamed: instanceVariableName put: (aRecord at: fieldName)! !!EmbededMapping methodsFor: 'mapping' stamp: 'HernanWilkinson 10/31/2016 23:31'!embeded: anObject into: aRecord	aRecord at: fieldName put: (anObject instVarNamed: instanceVariableName) ! !!EmbededMapping methodsFor: 'initialization' stamp: 'HernanWilkinson 10/31/2016 23:30'!initializeFor: anInstanceVariableName into: aFieldName	instanceVariableName := anInstanceVariableName.	fieldName := aFieldName ! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!EmbededMapping class	instanceVariableNames: ''!!EmbededMapping class methodsFor: 'instance creation' stamp: 'HernanWilkinson 10/31/2016 23:29'!withDefaultFieldNameFor: anInstanceVariableName	^self for: anInstanceVariableName into: (self defaultFieldNameFor: anInstanceVariableName)! !!EmbededMapping class methodsFor: 'instance creation' stamp: 'HernanWilkinson 10/31/2016 23:30'!for: anInstanceVariableName into: aFieldName	^self new initializeFor: anInstanceVariableName into: aFieldName ! !Mapping subclass: #OneToManyMapping	instanceVariableNames: 'relatedType fieldName'	classVariableNames: ''	poolDictionaries: ''	category: 'IS1-CustomerImport-PersistanceModel'!!OneToManyMapping methodsFor: 'mapping' stamp: 'HernanWilkinson 11/1/2016 01:37'!mapOneToManyRelationshipsOf: anObject using: aDataBaseSession	| oldCollection newCollection |	newCollection := self createRelationCollectionOn: aDataBaseSession ownedBy: anObject.	oldCollection := anObject instVarNamed: instanceVariableName.		newCollection addAll: oldCollection.	anObject instVarNamed: instanceVariableName put: newCollection! !!OneToManyMapping methodsFor: 'mapping' stamp: 'HernanWilkinson 11/1/2016 01:35'!createRelationCollectionOn: aDataBaseSession ownedBy: anObject	^ OneToManySet on: aDataBaseSession ownedBy: anObject! !!OneToManyMapping methodsFor: 'mapping' stamp: 'HernanWilkinson 11/1/2016 01:37'!unmap: aRecord into: anObject using: aDataBaseSession	| newCollection related |	related := aDataBaseSession relatedOfType: relatedType for: anObject.	newCollection := self createRelationCollectionOn: aDataBaseSession ownedBy: anObject.	newCollection addAllNotPersisting: related.	anObject instVarNamed: instanceVariableName put: newCollection! !!OneToManyMapping methodsFor: 'mapping' stamp: 'HernanWilkinson 10/31/2016 21:16'!embeded: anObject into: aRecord	! !!OneToManyMapping methodsFor: 'initialization' stamp: 'HernanWilkinson 10/31/2016 23:34'!initializeFor: anInstanceVariableName into: aFieldName ofType: aClass	instanceVariableName := anInstanceVariableName.	fieldName := aFieldName.	relatedType := aClass ! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!OneToManyMapping class	instanceVariableNames: ''!!OneToManyMapping class methodsFor: 'instance creation' stamp: 'HernanWilkinson 10/31/2016 23:40'!for: anInstanceVariableName into: aFieldName ofType: aClass	self assertValidFieldName: aFieldName.		^self new initializeFor: anInstanceVariableName into: aFieldName ofType: aClass! !!OneToManyMapping class methodsFor: 'instance creation' stamp: 'HernanWilkinson 10/31/2016 23:32'!withDefaultFieldNameFor: anInstanceVariableName ofType: aClass	^self for: anInstanceVariableName into: (self defaultFieldNameFor: anInstanceVariableName) ofType: aClass! !Set subclass: #OneToManySet	instanceVariableNames: 'session owner'	classVariableNames: ''	poolDictionaries: ''	category: 'IS1-CustomerImport-PersistanceModel'!!OneToManySet methodsFor: 'removing' stamp: 'HernanWilkinson 10/31/2016 21:35'!remove: anObject ifAbsent: anAbsentBlock	self shouldBeImplemented ! !!OneToManySet methodsFor: 'adding' stamp: 'HernanWilkinson 11/1/2016 00:03'!addAllNotPersisting: aCollection 		^aCollection do: [ :anObjectToAdd | super add: anObjectToAdd ]! !!OneToManySet methodsFor: 'adding' stamp: 'HernanWilkinson 11/1/2016 00:11'!add: anObject	session persist: anObject.	session addRelated: anObject ownedBy: owner.		super add: anObject.! !!OneToManySet methodsFor: 'initialization' stamp: 'HernanWilkinson 11/1/2016 00:11'!initializeOn: aDataBaseSession ownedBy: anOwner		session := aDataBaseSession.	owner := anOwner ! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!OneToManySet class	instanceVariableNames: ''!!OneToManySet class methodsFor: 'instance creation' stamp: 'HernanWilkinson 11/1/2016 00:11'!on: aDataBaseSession ownedBy: anOwner		^self new initializeOn: aDataBaseSession ownedBy: anOwner ! !'From Pharo6.0 of 13 May 2016 [Latest update: #60540] on 25 June 2018 at 3:22:47.41435 pm'!!String methodsFor: '*IS1-CustomerImport' stamp: 'HernanWilkinson 10/31/2016 23:57'!asPlural		^self last = $s 		ifTrue: [ self, 'es' ]		ifFalse: [ self, 's' ]! !'From Pharo6.0 of 13 May 2016 [Latest update: #60540] on 25 June 2018 at 3:22:47.414603 pm'!!Object methodsFor: '*IS1-CustomerImport' stamp: 'HernanWilkinson 10/31/2016 19:27'!toDo: aString 	! !